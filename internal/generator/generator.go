package generator

import (
	"log/slog"

	"github.com/csnewman/cuttle/internal/parser"
	"github.com/dave/jennifer/jen"
)

const cuttlePkg = "github.com/csnewman/cuttle"

func Generate(unit *parser.Unit, logger *slog.Logger, outPath string) error {
	f := jen.NewFile("main")
	f.HeaderComment("Code generated by " + cuttlePkg + ". DO NOT EDIT")

	g := &Generator{
		logger: logger,
		file:   f,
	}

	g.Generate(unit)

	return f.Save(outPath)
}

type Generator struct {
	logger *slog.Logger
	file   *jen.File
}

func (g *Generator) Generate(unit *parser.Unit) {
	g.file.ImportName(cuttlePkg, "cuttle")

	for _, name := range unit.RepositoriesOrder {
		repo := unit.Repositories[name]

		g.GenerateRepo(repo)
	}
}

func (g *Generator) GenerateRepo(repo *parser.Repository) {
	g.logger.Debug("Generating repository", "name", repo.Name)

	g.file.Type().Id(repo.Name).InterfaceFunc(func(jg *jen.Group) {
		for _, query := range repo.Queries {
			jg.Id(query.Name).ParamsFunc(func(jg *jen.Group) {
				jg.Id("ctx").Qual("context", "Context")
				jg.Id("tx").Qual(cuttlePkg, "WTx")

				for _, arg := range query.Args {
					jg.Id(arg.Name).Qual("", arg.Type)
				}
			})

			jg.Id(query.Name + "Async").ParamsFunc(func(jg *jen.Group) {
				jg.Id("tx").Qual(cuttlePkg, "WTx")

				for _, arg := range query.Args {
					jg.Id(arg.Name).Qual("", arg.Type)
				}

				jg.Id("callback").Qual(cuttlePkg, "AsyncHandler").Types(
					jen.Qual(cuttlePkg, "Exec"),
				)
			})
		}
	})
}
